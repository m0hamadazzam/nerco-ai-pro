/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

RED.userSettings = (function () {

    var trayWidth = 700;
    var themeSwitchInProgress = false;
    var currentThemeId = null;
    var settingsChangedImmediately = {}; // Track settings changed via immediate change handlers

    // Function to dynamically switch themes
    function switchTheme(themeId) {
        // Prevent multiple simultaneous theme switches
        if (themeSwitchInProgress) {
            return;
        }
        themeSwitchInProgress = true;
        // Remove old theme CSS files (both dynamically loaded and initial page load)
        // Find all theme CSS links by looking for links with theme URLs
        var allLinks = document.querySelectorAll('link[rel="stylesheet"]');
        allLinks.forEach(function (link) {
            var href = link.getAttribute('href') || '';
            // Check if this is a theme CSS file (starts with 'theme/css/')
            if (href.indexOf('theme/css/') !== -1) {
                if (link.parentNode) {
                    link.parentNode.removeChild(link);
                }
            }
        });

        // Call API to switch theme and get CSS files
        $.ajax({
            method: 'POST',
            contentType: 'application/json',
            url: 'theme/switch',
            data: JSON.stringify({ theme: themeId || '' }),
            success: function (response) {
                if (response && response.css && response.css.length > 0) {
                    // Dynamically load new theme CSS files
                    response.css.forEach(function (cssUrl) {
                        var link = document.createElement('link');
                        link.rel = 'stylesheet';
                        link.type = 'text/css';
                        link.href = cssUrl;
                        link.id = 'theme-css-' + cssUrl.replace(/[^a-zA-Z0-9]/g, '-');
                        document.head.appendChild(link);
                    });
                }

                // Update palette node colors to match theme
                updatePaletteNodeColors();

                // Show notification only if theme actually changed
                if (currentThemeId !== themeId) {
                    RED.notify(RED._("menu.label.view.themeChanged"), {
                        type: "success",
                        timeout: 3000,
                        fixed: false
                    });
                }
                currentThemeId = themeId;
                themeSwitchInProgress = false;
            },
            error: function (xhr, status, error) {
                RED.notify(RED._("menu.label.view.themeChangeError") + ": " + (error || "Unknown error"), {
                    type: "error",
                    timeout: 5000,
                    fixed: false
                });
                themeSwitchInProgress = false;
            }
        });
    }

    // Function to update palette node colors when theme changes
    function updatePaletteNodeColors() {
        // Clear the node color cache so colors are recalculated
        if (RED.utils.clearNodeColorCache) {
            RED.utils.clearNodeColorCache();
        }

        // Force a small delay to ensure CSS is loaded
        setTimeout(function () {
            // Update all palette nodes with new colors
            $('.red-ui-palette-node').each(function () {
                var $node = $(this);
                var nodeType = $node.attr('data-palette-type');
                if (nodeType) {
                    var nodeDef = RED.nodes.registry.get(nodeType);
                    if (nodeDef) {
                        var newColor = RED.utils.getNodeColor(nodeType, nodeDef);
                        // Only update if we got a valid color
                        if (newColor) {
                            $node.css('backgroundColor', newColor);
                        } else {
                            // If no color, remove inline style to let CSS handle it
                            $node.css('backgroundColor', '');
                        }
                    }
                }
            });
        }, 100);
    }
    var settingsVisible = false;

    var panes = [];

    function addPane(options) {
        panes.push(options);
    }

    function show(initialTab) {
        if (settingsVisible) {
            return;
        }
        if (!RED.user.hasPermission("settings.write")) {
            RED.notify(RED._("user.errors.settings"), "error");
            return;
        }
        settingsVisible = true;

        var trayOptions = {
            title: RED._("menu.label.userSettings"),
            buttons: [
                {
                    id: "node-dialog-ok",
                    text: RED._("common.label.close"),
                    class: "primary",
                    click: function () {
                        RED.tray.close();
                    }
                }
            ],
            resize: function (dimensions) {
                trayWidth = dimensions.width;
            },
            open: function (tray) {
                var trayBody = tray.find('.red-ui-tray-body');
                var settingsContent = $('<div></div>').appendTo(trayBody);
                var tabContainer = $('<div></div>', { class: "red-ui-settings-tabs-container" }).appendTo(settingsContent);

                $('<ul></ul>', { id: "user-settings-tabs" }).appendTo(tabContainer);
                var settingsTabs = RED.tabs.create({
                    id: "user-settings-tabs",
                    vertical: true,
                    onchange: function (tab) {
                        setTimeout(function () {
                            tabContents.children().hide();
                            $("#" + tab.id).show();
                            if (tab.pane.focus) {
                                tab.pane.focus();
                            }
                        }, 50);
                    }
                });
                var tabContents = $('<div></div>', { class: "red-ui-settings-tabs-content" }).appendTo(settingsContent);

                panes.forEach(function (pane) {
                    settingsTabs.addTab({
                        id: "red-ui-settings-tab-" + pane.id,
                        label: pane.title,
                        pane: pane
                    });
                    pane.get().hide().appendTo(tabContents);
                });
                settingsContent.i18n();
                settingsTabs.activateTab("red-ui-settings-tab-" + (initialTab || 'view'))
                $("#red-ui-sidebar-shade").show();
            },
            close: function () {
                settingsVisible = false;
                panes.forEach(function (pane) {
                    if (pane.close) {
                        pane.close();
                    }
                });
                $("#red-ui-sidebar-shade").hide();

            },
            show: function () { }
        }
        if (trayWidth !== null) {
            trayOptions.width = trayWidth;
        }
        RED.tray.show(trayOptions);
    }

    function localeToName(lc) {
        var name = RED._("languages." + lc);
        return { text: (name ? name : lc), val: lc };
    }

    function compText(a, b) {
        return a.text.localeCompare(b.text);
    }

    var viewSettings = [
        {
            options: [
                { setting: "editor-language", local: true, label: "menu.label.view.language", options: function (done) { done([{ val: '', text: RED._('menu.label.view.browserDefault') }].concat(RED.settings.theme("languages").map(localeToName).sort(compText))) } },
                {
                    setting: "editor-theme", label: "menu.label.view.theme", options: function (done) {
                        // Always start with Default option
                        var themeOptions = [{ val: '', text: 'Default' }];

                        // Try to load available themes from the theme API
                        $.ajax({
                            url: 'theme/',
                            dataType: 'json',
                            timeout: 5000, // 5 second timeout
                            success: function (data) {
                                if (data && data.themes && Array.isArray(data.themes) && data.themes.length > 0) {
                                    data.themes.forEach(function (themeId) {
                                        themeOptions.push({ val: themeId, text: themeId });
                                    });
                                }
                                done(themeOptions);
                            },
                            error: function (xhr, status, error) {
                                // Fallback: try to get themes from settings
                                try {
                                    var themes = RED.settings.theme("themes");
                                    if (themes && Array.isArray(themes) && themes.length > 0) {
                                        themes.forEach(function (themeId) {
                                            themeOptions.push({ val: themeId, text: themeId });
                                        });
                                    }
                                } catch (e) {
                                    // Ignore errors, just use Default
                                }
                                // Always call done with at least Default option
                                done(themeOptions);
                            }
                        });
                    }, onchange: function (val) {
                        // Save theme preference to user settings (for UI display)
                        var currentEditorSettings = RED.settings.get('editor') || {};
                        currentEditorSettings.view = currentEditorSettings.view || {};
                        currentEditorSettings.view['editor-theme'] = val;
                        RED.settings.set('editor', currentEditorSettings);

                        // Switch theme dynamically
                        switchTheme(val);
                    }
                }
            ]
        },
        {
            title: "menu.label.view.view",
            options: [
                { setting: "view-store-zoom", label: "menu.label.view.storeZoom", default: false, toggle: true, onchange: function (val) { if (!val) { RED.settings.removeLocal("zoom-level") } } },
                { setting: "view-store-position", label: "menu.label.view.storePosition", default: false, toggle: true, onchange: function (val) { if (!val) { RED.settings.removeLocal("scroll-positions") } } },
            ]
        },
        {
            title: "menu.label.view.grid",
            options: [
                { setting: "view-show-grid", oldSetting: "menu-menu-item-view-show-grid", label: "menu.label.view.showGrid", default: true, toggle: true, onchange: "core:toggle-show-grid" },
                { setting: "view-snap-grid", oldSetting: "menu-menu-item-view-snap-grid", label: "menu.label.view.snapGrid", default: true, toggle: true, onchange: "core:toggle-snap-grid" },
                { setting: "view-grid-size", label: "menu.label.view.gridSize", type: "number", default: 20, onchange: RED.view.gridSize }
            ]
        },
        {
            title: "menu.label.nodes",
            options: [
                { setting: "view-node-status", oldSetting: "menu-menu-item-status", label: "menu.label.displayStatus", default: true, toggle: true, onchange: "core:toggle-status" },
                { setting: "view-node-show-label", label: "menu.label.showNodeLabelDefault", default: true, toggle: true }
            ]
        },
        {
            title: "menu.label.other",
            options: [
                { setting: "view-show-tips", oldSettings: "menu-menu-item-show-tips", label: "menu.label.showTips", toggle: true, default: true, onchange: "core:toggle-show-tips" },
                { setting: "view-show-welcome-tours", label: "menu.label.showWelcomeTours", toggle: true, default: true }
            ]
        }
    ];

    var allSettings = {};

    function createViewPane() {

        var pane = $('<div id="red-ui-settings-tab-view" class="red-ui-help"></div>');

        var currentEditorSettings = RED.settings.get('editor') || {};
        currentEditorSettings.view = currentEditorSettings.view || {};

        viewSettings.forEach(function (section) {
            if (section.title) {
                $('<h3></h3>').text(RED._(section.title)).appendTo(pane);
            }
            section.options.forEach(function (opt) {
                var initialState;
                if (opt.local) {
                    initialState = localStorage.getItem(opt.setting);
                } else {
                    // For theme, get current value from editorTheme settings
                    if (opt.setting === "editor-theme") {
                        initialState = RED.settings.theme("theme") || currentEditorSettings.view[opt.setting] || '';
                    } else {
                        initialState = currentEditorSettings.view[opt.setting];
                    }
                }
                var row = $('<div class="red-ui-settings-row"></div>').appendTo(pane);
                var input;
                if (opt.toggle) {
                    input = $('<label for="user-settings-' + opt.setting + '"><input id="user-settings-' + opt.setting + '" type="checkbox"> ' + RED._(opt.label) + '</label>').appendTo(row).find("input");
                    input.prop('checked', initialState);
                } else if (opt.options) {
                    $('<label for="user-settings-' + opt.setting + '">' + RED._(opt.label) + '</label>').appendTo(row);
                    var select = $('<select id="user-settings-' + opt.setting + '"></select>').appendTo(row);
                    // Add change event handler to trigger onchange callback immediately
                    select.on('change', function () {
                        if (opt.onchange) {
                            settingsChangedImmediately[opt.setting] = true;
                            setSelected(opt.setting, select.val());
                        }
                    });
                    if (typeof opt.options === 'function') {
                        // For async options (like theme), add a loading option first
                        if (opt.setting === "editor-theme") {
                            $('<option>').val('').text('Loading...').appendTo(select);
                        }
                        opt.options(function (options) {
                            // Clear existing options if this is the theme selector
                            if (opt.setting === "editor-theme") {
                                select.empty();
                            }
                            if (options && options.length > 0) {
                                options.forEach(function (opt) {
                                    var val = opt;
                                    var text = opt;
                                    if (typeof opt !== 'string') {
                                        val = opt.val;
                                        text = opt.text;
                                    }
                                    $('<option>').val(val).text(text).appendTo(select);
                                })
                                select.val(initialState)
                            } else {
                                // If no options returned, at least add Default
                                $('<option>').val('').text('Default').appendTo(select);
                                select.val(initialState)
                            }
                        })
                    } else {
                        // TODO: support other option types
                    }
                } else {
                    $('<label for="user-settings-' + opt.setting + '">' + RED._(opt.label) + '</label>').appendTo(row);
                    $('<input id="user-settings-' + opt.setting + '" type="' + (opt.type || "text") + '">').appendTo(row).val(initialState);
                }
            });
        })
        return pane;
    }

    function setSelected(id, value) {
        var opt = allSettings[id];
        if (opt.local) {
            localStorage.setItem(opt.setting, value);
        } else {
            var currentEditorSettings = RED.settings.get('editor') || {};
            currentEditorSettings.view = currentEditorSettings.view || {};
            currentEditorSettings.view[opt.setting] = value;
            RED.settings.set('editor', currentEditorSettings);
            var callback = opt.onchange;
            if (typeof callback === 'string') {
                callback = RED.actions.get(callback);
            }
            if (callback) {
                callback.call(opt, value);
            }
        }
    }
    function toggle(id) {
        var opt = allSettings[id];
        var currentEditorSettings = RED.settings.get('editor') || {};
        currentEditorSettings.view = currentEditorSettings.view || {};
        setSelected(id, !currentEditorSettings.view[opt.setting]);
    }


    function createAISettingsPane() {
        var pane = $('<div id="red-ui-settings-tab-ai" class="red-ui-help"></div>');

        // Migration: Check for legacy localStorage key and migrate
        var legacyKey = localStorage.getItem('node-red-openai-api-key');
        if (legacyKey && legacyKey.trim().length > 0) {
            var aiProviders = RED.settings.get('aiProviders', {});
            if (!aiProviders.openai || !aiProviders.openai.keys || aiProviders.openai.keys.length === 0) {
                // Migrate legacy key
                if (!aiProviders.openai) {
                    aiProviders.openai = { keys: [] };
                }
                if (!aiProviders.openai.keys) {
                    aiProviders.openai.keys = [];
                }
                aiProviders.openai.keys.push({
                    id: 'migrated-' + Date.now(),
                    name: 'Migrated Key',
                    apiKey: legacyKey,
                    enabled: true,
                    createdAt: new Date().toISOString()
                });
                RED.settings.set('aiProviders', aiProviders);
                // Clear legacy key
                localStorage.removeItem('node-red-openai-api-key');
            }
        }

        var aiProviders = RED.settings.get('aiProviders', {});
        var providers = RED.aiModels.getAllProviders();

        providers.forEach(function (providerInfo) {
            var providerId = providerInfo.id;
            var provider = aiProviders[providerId] || { keys: [] };
            if (!provider.keys) {
                provider.keys = [];
            }

            // Provider section
            var providerSection = $('<div class="red-ui-ai-provider-section"></div>').appendTo(pane);

            // Provider header
            var providerHeader = $('<div class="red-ui-ai-provider-header"></div>').appendTo(providerSection);

            var providerIcon = $('<i class="fa ' + providerInfo.icon + '"></i>').appendTo(providerHeader);
            providerIcon.css({
                'color': providerInfo.color
            });

            var providerTitle = $('<h3>' + providerInfo.name + '</h3>').appendTo(providerHeader);

            // Keys list
            var keysContainer = $('<div class="red-ui-ai-keys-container"></div>').appendTo(providerSection);

            // Existing keys
            provider.keys.forEach(function (key, index) {
                createKeyRow(keysContainer, providerId, key, index);
            });

            // Add new key button
            var addKeyButton = $('<button class="red-ui-button red-ui-button-small">Add API Key</button>').appendTo(providerSection);
            addKeyButton.css({
                'margin-top': '10px'
            });
            addKeyButton.on('click', function () {
                var currentProviders = RED.settings.get('aiProviders', {});
                if (!currentProviders[providerId]) {
                    currentProviders[providerId] = { keys: [] };
                }
                var newKey = {
                    id: 'key-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
                    name: '',
                    apiKey: '',
                    enabled: true,
                    createdAt: new Date().toISOString()
                };
                currentProviders[providerId].keys.push(newKey);
                createKeyRow(keysContainer, providerId, newKey, currentProviders[providerId].keys.length - 1);
                updateProviderKeys(providerId, currentProviders[providerId].keys);
            });
        });

        function createKeyRow(container, providerId, key, index) {
            var keyRow = $('<div class="red-ui-ai-key-row"></div>').appendTo(container);

            var keyRowTop = $('<div class="red-ui-ai-key-row-top"></div>').appendTo(keyRow);

            // Key name input
            var nameInput = $('<input type="text" placeholder="Key name (e.g., Personal, Work)" class="red-ui-ai-key-name">').appendTo(keyRowTop);
            nameInput.val(key.name || '');
            nameInput.on('change', function () {
                key.name = nameInput.val();
                // Get all keys for this provider and update
                var currentProviders = RED.settings.get('aiProviders', {});
                if (!currentProviders[providerId]) {
                    currentProviders[providerId] = { keys: [] };
                }
                // Find and update the key in the array
                var keyIndex = currentProviders[providerId].keys.findIndex(function (k) { return k.id === key.id; });
                if (keyIndex >= 0) {
                    currentProviders[providerId].keys[keyIndex] = key;
                } else {
                    currentProviders[providerId].keys.push(key);
                }
                updateProviderKeys(providerId, currentProviders[providerId].keys);
            });

            // Enabled toggle
            var enabledLabel = $('<label class="red-ui-ai-key-enabled"><input type="checkbox">Enabled</label>').appendTo(keyRowTop);
            var enabledCheckbox = enabledLabel.find('input');
            enabledCheckbox.prop('checked', key.enabled !== false);
            enabledCheckbox.on('change', function () {
                key.enabled = enabledCheckbox.prop('checked');
                // Get all keys for this provider and update
                var currentProviders = RED.settings.get('aiProviders', {});
                if (!currentProviders[providerId]) {
                    currentProviders[providerId] = { keys: [] };
                }
                // Find and update the key in the array
                var keyIndex = currentProviders[providerId].keys.findIndex(function (k) { return k.id === key.id; });
                if (keyIndex >= 0) {
                    currentProviders[providerId].keys[keyIndex] = key;
                } else {
                    currentProviders[providerId].keys.push(key);
                }
                updateProviderKeys(providerId, currentProviders[providerId].keys);
            });

            // Delete button
            var deleteButton = $('<button class="red-ui-button red-ui-button-small red-ui-ai-key-delete-button">Delete</button>').appendTo(keyRowTop);
            deleteButton.on('click', function () {
                if (confirm('Are you sure you want to delete this API key?')) {
                    var currentProviders = RED.settings.get('aiProviders', {});
                    if (!currentProviders[providerId]) {
                        currentProviders[providerId] = { keys: [] };
                    }
                    // Find and remove the key by ID
                    currentProviders[providerId].keys = currentProviders[providerId].keys.filter(k => k.id !== key.id);
                    keyRow.remove();
                    updateProviderKeys(providerId, currentProviders[providerId].keys);
                }
            });

            // API key input
            var apiKeyInput = $('<input type="password" placeholder="Enter API key..." class="red-ui-ai-key-value">').appendTo(keyRow);

            // Show masked value if key exists
            if (key.apiKey && typeof key.apiKey === 'string' && key.apiKey.length >= 8) {
                var masked = key.apiKey.substring(0, 4) + '...' + key.apiKey.substring(key.apiKey.length - 4);
                apiKeyInput.attr('placeholder', 'Current key: ' + masked);
            } else if (key.apiKey && typeof key.apiKey === 'string' && key.apiKey.length > 0) {
                // For keys shorter than 8 characters, just show first 4
                var masked = key.apiKey.substring(0, Math.min(4, key.apiKey.length)) + '...';
                apiKeyInput.attr('placeholder', 'Current key: ' + masked);
            }

            apiKeyInput.on('change', function () {
                var newKey = apiKeyInput.val().trim();
                if (newKey && newKey.length > 0) {
                    key.apiKey = newKey;
                    // Get all keys for this provider and update
                    var currentProviders = RED.settings.get('aiProviders', {});
                    if (!currentProviders[providerId]) {
                        currentProviders[providerId] = { keys: [] };
                    }
                    // Find and update the key in the array
                    var keyIndex = currentProviders[providerId].keys.findIndex(function (k) { return k.id === key.id; });
                    if (keyIndex >= 0) {
                        currentProviders[providerId].keys[keyIndex] = key;
                    } else {
                        currentProviders[providerId].keys.push(key);
                    }
                    updateProviderKeys(providerId, currentProviders[providerId].keys);
                    // Update placeholder to show masked value
                    if (newKey.length >= 8) {
                        var masked = newKey.substring(0, 4) + '...' + newKey.substring(newKey.length - 4);
                        apiKeyInput.attr('placeholder', 'Current key: ' + masked);
                    } else {
                        var masked = newKey.substring(0, Math.min(4, newKey.length)) + '...';
                        apiKeyInput.attr('placeholder', 'Current key: ' + masked);
                    }
                    apiKeyInput.val('');
                }
            });
        }

        function updateProviderKeys(providerId, keys) {
            var aiProviders = RED.settings.get('aiProviders', {});
            if (!aiProviders[providerId]) {
                aiProviders[providerId] = { keys: [] };
            }
            // Get original keys to preserve apiKey values
            var originalKeys = aiProviders[providerId].keys || [];
            // Create a map of original keys by ID for quick lookup
            var originalKeysMap = {};
            originalKeys.forEach(function (k) {
                originalKeysMap[k.id] = k;
            });

            // Update the keys array, preserving the apiKey if it wasn't explicitly changed
            aiProviders[providerId].keys = keys.map(function (k) {
                var originalKey = originalKeysMap[k.id];
                // If we have an original key and the new key doesn't have an apiKey set, preserve it
                if (originalKey && originalKey.apiKey && typeof originalKey.apiKey === 'string') {
                    // Only preserve if the key object doesn't have apiKey or it's empty
                    // But if the key object has apiKey set (from the input), use that
                    if (!k.hasOwnProperty('apiKey') || !k.apiKey || k.apiKey === '' || typeof k.apiKey !== 'string') {
                        k.apiKey = originalKey.apiKey;
                    }
                }
                // Ensure apiKey is a string if it exists
                if (k.apiKey && typeof k.apiKey !== 'string') {
                    k.apiKey = String(k.apiKey);
                }
                // Ensure all required fields are present
                if (!k.id) k.id = 'key-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                if (k.enabled === undefined) k.enabled = true;
                return k;
            });
            RED.settings.set('aiProviders', aiProviders);
            // Trigger settings changed event
            if (RED.events && RED.events.emit) {
                RED.events.emit('settings:changed');
            }
        }

        return pane;
    }

    function init() {
        RED.actions.add("core:show-user-settings", show);
        RED.actions.add("core:show-help", function () { show('keyboard') });

        addPane({
            id: 'view',
            title: RED._("menu.label.view.view"),
            get: createViewPane,
            close: function () {
                viewSettings.forEach(function (section) {
                    section.options.forEach(function (opt) {
                        // Skip settings that were already changed via immediate change handlers
                        // (they're already saved and onchange was already called)
                        if (!settingsChangedImmediately[opt.setting]) {
                            var input = $("#user-settings-" + opt.setting);
                            if (opt.toggle) {
                                setSelected(opt.setting, input.prop('checked'));
                            } else {
                                setSelected(opt.setting, input.val());
                            }
                        }
                    });
                });
                // Reset tracking for next time settings window opens
                settingsChangedImmediately = {};
            }
        });

        // Add AI settings pane
        addPane({
            id: 'ai',
            title: 'AI Assistant',
            get: createAISettingsPane
        });

        var currentEditorSettings = RED.settings.get('editor') || {};
        currentEditorSettings.view = currentEditorSettings.view || {};
        var editorSettingsChanged = false;
        viewSettings.forEach(function (section) {
            section.options.forEach(function (opt) {
                if (opt.local) {
                    allSettings[opt.setting] = opt;
                    return;
                }
                if (opt.oldSetting) {
                    var oldValue = RED.settings.get(opt.oldSetting);
                    if (oldValue !== undefined && oldValue !== null) {
                        currentEditorSettings.view[opt.setting] = oldValue;
                        editorSettingsChanged = true;
                        RED.settings.remove(opt.oldSetting);
                    }
                }
                allSettings[opt.setting] = opt;
                var value = currentEditorSettings.view[opt.setting];
                if ((value === null || value === undefined) && opt.hasOwnProperty('default')) {
                    value = opt.default;
                    currentEditorSettings.view[opt.setting] = value;
                    editorSettingsChanged = true;
                }

                if (opt.onchange) {
                    var callback = opt.onchange;
                    if (typeof callback === 'string') {
                        callback = RED.actions.get(callback);
                    }
                    if (callback) {
                        // Initialize currentThemeId before calling callback to prevent notification on page load
                        if (opt.setting === "editor-theme") {
                            currentThemeId = value || '';
                        }
                        callback.call(opt, value);
                    }
                }
            });
        });
        if (editorSettingsChanged) {
            RED.settings.set('editor', currentEditorSettings);
        }

    }
    return {
        init: init,
        toggle: toggle,
        show: show,
        add: addPane
    };
})();
