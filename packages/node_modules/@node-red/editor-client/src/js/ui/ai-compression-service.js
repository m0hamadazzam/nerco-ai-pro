/**
 * AI Compression Service
 * Removes redundant and duplicate information from context
 */
RED.aiCompressionService = (function () {
    // Constants
    const COMPRESSION_LOG_THRESHOLD = 0; // Log if reduction is greater than this percentage

    /**
     * Remove duplicate node type definitions
     * If multiple node types have identical or very similar properties, keep only one
     */
    function deduplicateNodeTypes(nodeTypes) {
        if (!nodeTypes || typeof nodeTypes !== 'object') {
            return nodeTypes;
        }

        var seen = {};
        var deduplicated = {};
        var duplicates = [];

        for (var nodeType in nodeTypes) {
            if (!nodeTypes.hasOwnProperty(nodeType)) {
                continue;
            }

            var def = nodeTypes[nodeType];
            // Create a signature based on key properties
            var signature = createNodeTypeSignature(def);

            if (seen[signature]) {
                // This is a duplicate or very similar node type
                duplicates.push(nodeType);
                // Keep the first one, skip this one
                continue;
            }

            seen[signature] = true;
            deduplicated[nodeType] = def;
        }

        if (duplicates.length > 0) {
            var logMessage = 'Compression: Removed ' + duplicates.length + ' duplicate/similar node types';
            if (RED.log && RED.log.debug) {
                RED.log.debug(logMessage);
            } else {
                console.log(logMessage);
            }
        }

        return deduplicated;
    }

    /**
     * Create a signature for a node type based on its key properties
     */
    function createNodeTypeSignature(def) {
        if (!def) {
            return '';
        }

        var keyProps = [
            def.category || '',
            def.name || '',
            (def.inputs || 0).toString(),
            (def.outputs || 0).toString(),
            def.help ? def.help.substring(0, 100) : '' // First 100 chars of help
        ].join('|');

        return keyProps;
    }

    /**
     * Remove redundant information from workspace nodes
     * Remove properties that are not needed for AI context
     */
    function compressWorkspace(workspace) {
        if (!workspace || !Array.isArray(workspace)) {
            return workspace;
        }

        return workspace.map(function (node) {
            // Keep only essential properties
            var compressed = {
                id: node.id,
                type: node.type,
                name: node.name || '',
                x: node.x,
                y: node.y,
                z: node.z
            };

            // Only include wires if they exist and are non-empty
            if (node.wires && node.wires.length > 0) {
                compressed.wires = node.wires;
            }

            // Include critical properties that affect flow behavior
            // But exclude internal/UI properties
            var criticalProps = ['topic', 'payload', 'method', 'url', 'property', 'to', 'complete'];
            criticalProps.forEach(function (prop) {
                if (node[prop] !== undefined && node[prop] !== null && node[prop] !== '') {
                    compressed[prop] = node[prop];
                }
            });

            return compressed;
        });
    }

    /**
     * Remove redundant information from node type definitions
     * Keep only what's needed for AI to understand and use the node
     */
    function compressNodeTypeDefinition(def) {
        if (!def) {
            return def;
        }

        var compressed = {
            type: def.type,
            name: def.name || def.type,
            category: def.category || 'unknown',
            inputs: def.inputs || 0,
            outputs: def.outputs || 0
        };

        // Include help text (important for understanding)
        if (def.help) {
            compressed.help = def.help;
        }

        // Include label function or value if it's a string
        if (def.label) {
            if (typeof def.label === 'string') {
                compressed.label = def.label;
            } else if (typeof def.label === 'function') {
                // For functions, we can't compress, but we can note it exists
                compressed.hasLabelFunction = true;
            }
        }

        // Include defaults but only key properties (not full schema)
        if (def.defaults) {
            compressed.defaults = {};
            for (var prop in def.defaults) {
                if (def.defaults.hasOwnProperty(prop)) {
                    var defaultDef = def.defaults[prop];
                    // Only keep value and type, skip validation functions, etc.
                    compressed.defaults[prop] = {
                        value: defaultDef.value,
                        type: defaultDef.type
                    };
                }
            }
        }

        // Exclude: oneditprepare, oneditcancel, oneditsave, onpaletteadd, etc.
        // These are UI functions not needed for AI understanding

        return compressed;
    }

    /**
     * Compress node types object by compressing each definition
     */
    function compressNodeTypes(nodeTypes) {
        if (!nodeTypes || typeof nodeTypes !== 'object') {
            return nodeTypes;
        }

        var compressed = {};
        var originalSize = JSON.stringify(nodeTypes).length;

        for (var nodeType in nodeTypes) {
            if (nodeTypes.hasOwnProperty(nodeType)) {
                compressed[nodeType] = compressNodeTypeDefinition(nodeTypes[nodeType]);
            }
        }

        var compressedSize = JSON.stringify(compressed).length;
        var reduction = ((originalSize - compressedSize) / originalSize * 100).toFixed(1);

        if (reduction > COMPRESSION_LOG_THRESHOLD) {
            // Use RED.log if available, otherwise console.log
            var logMessage = 'Compression: Node types reduced by ' + reduction + '% (' +
                formatBytes(originalSize) + ' -> ' + formatBytes(compressedSize) + ')';
            if (RED.log && RED.log.debug) {
                RED.log.debug(logMessage);
            } else {
                console.log(logMessage);
            }
        }

        return compressed;
    }

    /**
     * Format bytes to human-readable string
     */
    function formatBytes(bytes) {
        if (bytes < 1024) {
            return bytes + ' B';
        }
        if (bytes < 1024 * 1024) {
            return (bytes / 1024).toFixed(1) + ' KB';
        }
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    /**
     * Remove duplicate messages from history
     * If consecutive messages are identical or very similar, keep only one
     */
    function deduplicateHistory(history) {
        if (!history || !Array.isArray(history) || history.length <= 1) {
            return history;
        }

        var deduplicated = [];
        var lastMessage = null;

        history.forEach(function (msg) {
            // Skip if this message is identical to the last one
            if (lastMessage &&
                lastMessage.role === msg.role &&
                lastMessage.content === msg.content) {
                return; // Skip duplicate
            }

            // Check for very similar messages (same role, similar content)
            if (lastMessage &&
                lastMessage.role === msg.role &&
                lastMessage.role === 'assistant' &&
                areMessagesSimilar(lastMessage.content, msg.content)) {
                // Keep the more recent one
                deduplicated.pop();
            }

            deduplicated.push(msg);
            lastMessage = msg;
        });

        if (deduplicated.length < history.length) {
            var logMessage = 'Compression: Removed ' + (history.length - deduplicated.length) + ' duplicate messages from history';
            if (RED.log && RED.log.debug) {
                RED.log.debug(logMessage);
            } else {
                console.log(logMessage);
            }
        }

        return deduplicated;
    }

    /**
     * Check if two messages are very similar (simple heuristic)
     */
    function areMessagesSimilar(msg1, msg2) {
        if (!msg1 || !msg2) {
            return false;
        }
        if (msg1 === msg2) {
            return true;
        }

        // If messages are very short and mostly the same, consider them similar
        var s1 = String(msg1).toLowerCase().trim();
        var s2 = String(msg2).toLowerCase().trim();

        if (s1.length < 50 && s2.length < 50) {
            // For short messages, check if they're very similar
            var similarity = calculateStringSimilarity(s1, s2);
            return similarity > 0.8; // 80% similar
        }

        return false;
    }

    /**
     * Simple string similarity calculation (Jaccard similarity)
     */
    function calculateStringSimilarity(s1, s2) {
        var words1 = new Set(s1.split(/\s+/));
        var words2 = new Set(s2.split(/\s+/));

        var intersection = 0;
        words1.forEach(function (word) {
            if (words2.has(word)) {
                intersection++;
            }
        });

        var union = words1.size + words2.size - intersection;
        return union > 0 ? intersection / union : 0;
    }

    /**
     * Main compression function - applies all compression techniques
     */
    function compressContext(context) {
        var compressed = {
            nodeTypes: context.nodeTypes,
            workspace: context.workspace,
            history: context.history
        };

        // Compress node types
        if (context.nodeTypes) {
            compressed.nodeTypes = compressNodeTypes(context.nodeTypes);
            compressed.nodeTypes = deduplicateNodeTypes(compressed.nodeTypes);
        }

        // Compress workspace
        if (context.workspace) {
            compressed.workspace = compressWorkspace(context.workspace);
        }

        // Deduplicate history
        if (context.history) {
            compressed.history = deduplicateHistory(context.history);
        }

        return compressed;
    }

    return {
        compressContext: compressContext,
        compressNodeTypes: compressNodeTypes,
        compressWorkspace: compressWorkspace,
        deduplicateHistory: deduplicateHistory,
        deduplicateNodeTypes: deduplicateNodeTypes
    };
})();

