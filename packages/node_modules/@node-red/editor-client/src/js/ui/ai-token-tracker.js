/**
 * AI Token Tracker
 * Tracks token usage across AI providers and models
 */
RED.aiTokenTracker = (function() {
    var sessionStats = {
        totalTokens: 0,
        totalCost: 0,
        requestCount: 0,
        perModel: {},
        perOperation: {}
    };

    // Pricing per 1M tokens (input/output)
    var pricing = {
        openai: {
            'gpt-4o': { input: 2.50, output: 10.00 },
            'gpt-4o-mini': { input: 0.15, output: 0.60 },
            'gpt-4-turbo': { input: 10.00, output: 30.00 },
            'gpt-4': { input: 30.00, output: 60.00 },
            'gpt-3.5-turbo': { input: 0.50, output: 1.50 }
        },
        anthropic: {
            'claude-3-5-sonnet-20241022': { input: 3.00, output: 15.00 },
            'claude-3-5-haiku-20241022': { input: 0.80, output: 4.00 },
            'claude-3-opus-20240229': { input: 15.00, output: 75.00 },
            'claude-3-sonnet-20240229': { input: 3.00, output: 15.00 }
        },
        gemini: {
            'gemini-1.5-pro': { input: 1.25, output: 5.00 },
            'gemini-1.5-flash': { input: 0.075, output: 0.30 },
            'gemini-pro': { input: 0.50, output: 2.00 }
        }
    };

    /**
     * Extract token usage from API response
     */
    function extractTokenUsage(apiResponse, provider) {
        var usage = {
            promptTokens: 0,
            completionTokens: 0,
            totalTokens: 0
        };

        if (!apiResponse) {
            return usage;
        }

        switch (provider) {
            case 'openai':
                if (apiResponse.usage) {
                    usage.promptTokens = apiResponse.usage.prompt_tokens || 0;
                    usage.completionTokens = apiResponse.usage.completion_tokens || 0;
                    usage.totalTokens = apiResponse.usage.total_tokens || 0;
                }
                break;

            case 'anthropic':
                if (apiResponse.usage) {
                    usage.promptTokens = apiResponse.usage.input_tokens || 0;
                    usage.completionTokens = apiResponse.usage.output_tokens || 0;
                    usage.totalTokens = (apiResponse.usage.input_tokens || 0) + (apiResponse.usage.output_tokens || 0);
                }
                break;

            case 'gemini':
                // Gemini returns usage in usageMetadata
                if (apiResponse.usageMetadata) {
                    usage.promptTokens = apiResponse.usageMetadata.promptTokenCount || 0;
                    usage.completionTokens = apiResponse.usageMetadata.candidatesTokenCount || 0;
                    usage.totalTokens = apiResponse.usageMetadata.totalTokenCount || 0;
                }
                // Also check for direct usage property (some Gemini responses)
                else if (apiResponse.usage) {
                    usage.promptTokens = apiResponse.usage.promptTokenCount || 0;
                    usage.completionTokens = apiResponse.usage.candidatesTokenCount || 0;
                    usage.totalTokens = apiResponse.usage.totalTokenCount || 0;
                }
                break;
        }

        return usage;
    }

    /**
     * Calculate cost based on tokens and model
     */
    function calculateCost(usage, model, provider) {
        if (!pricing[provider] || !pricing[provider][model]) {
            return 0;
        }

        var modelPricing = pricing[provider][model];
        var inputCost = (usage.promptTokens / 1000000) * modelPricing.input;
        var outputCost = (usage.completionTokens / 1000000) * modelPricing.output;

        return inputCost + outputCost;
    }

    /**
     * Track token usage for a request
     */
    function track(apiResponse, provider, model, operation) {
        var usage = extractTokenUsage(apiResponse, provider);
        var cost = calculateCost(usage, model, provider);

        // Update session stats
        sessionStats.totalTokens += usage.totalTokens;
        sessionStats.totalCost += cost;
        sessionStats.requestCount += 1;

        // Track per model
        var modelKey = provider + ':' + model;
        if (!sessionStats.perModel[modelKey]) {
            sessionStats.perModel[modelKey] = {
                tokens: 0,
                cost: 0,
                requests: 0
            };
        }
        sessionStats.perModel[modelKey].tokens += usage.totalTokens;
        sessionStats.perModel[modelKey].cost += cost;
        sessionStats.perModel[modelKey].requests += 1;

        // Track per operation
        if (operation) {
            if (!sessionStats.perOperation[operation]) {
                sessionStats.perOperation[operation] = {
                    tokens: 0,
                    cost: 0,
                    requests: 0
                };
            }
            sessionStats.perOperation[operation].tokens += usage.totalTokens;
            sessionStats.perOperation[operation].cost += cost;
            sessionStats.perOperation[operation].requests += 1;
        }

        return {
            usage: usage,
            cost: cost,
            sessionStats: getSessionStats()
        };
    }

    /**
     * Get current session statistics
     */
    function getSessionStats() {
        return {
            totalTokens: sessionStats.totalTokens,
            totalCost: sessionStats.totalCost,
            requestCount: sessionStats.requestCount,
            perModel: JSON.parse(JSON.stringify(sessionStats.perModel)),
            perOperation: JSON.parse(JSON.stringify(sessionStats.perOperation))
        };
    }

    /**
     * Reset session statistics
     */
    function reset() {
        sessionStats = {
            totalTokens: 0,
            totalCost: 0,
            requestCount: 0,
            perModel: {},
            perOperation: {}
        };
    }

    return {
        track: track,
        getSessionStats: getSessionStats,
        reset: reset,
        extractTokenUsage: extractTokenUsage
    };
})();

