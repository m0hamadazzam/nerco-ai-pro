/**
 * AI Module Installer Service
 * Handles automatic detection and installation of missing Node-RED modules
 */
RED.aiModuleInstaller = (function() {
    // Deprecated node type mappings (from Node-RED core)
    // These are node types that moved from core to separate modules
    var deprecatedMappings = {
        "irc in": "node-red-node-irc",
        "irc out": "node-red-node-irc",
        "irc-server": "node-red-node-irc",
        "arduino in": "node-red-node-arduino",
        "arduino out": "node-red-node-arduino",
        "arduino-board": "node-red-node-arduino",
        "redis out": "node-red-node-redis",
        "mongodb": "node-red-node-mongodb",
        "mongodb out": "node-red-node-mongodb",
        "serial in": "node-red-node-serialport",
        "serial out": "node-red-node-serialport",
        "serial-port": "node-red-node-serialport",
        "twitter-credentials": "node-red-node-twitter",
        "twitter in": "node-red-node-twitter",
        "twitter out": "node-red-node-twitter",
        "e-mail": "node-red-node-email",
        "e-mail in": "node-red-node-email",
        "feedparse": "node-red-node-feedparser",
        "sentiment": "node-red-node-sentiment",
        "tail": "node-red-node-tail",
        "rpi-gpio in": "node-red-node-pi-gpio",
        "rpi-gpio out": "node-red-node-pi-gpio",
        "rpi-mouse": "node-red-node-pi-gpio",
        "rpi-keyboard": "node-red-node-pi-gpio"
    };

    /**
     * Convert camelCase to kebab-case
     */
    function camelToKebab(str) {
        return str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
    }

    /**
     * Try to determine module name for a node type
     * Returns module name if found, null otherwise
     */
    function getModuleNameForNodeType(nodeType) {
        if (!nodeType || typeof nodeType !== 'string') {
            return null;
        }

        // Strategy 1: Check deprecated mappings (old core nodes)
        if (deprecatedMappings.hasOwnProperty(nodeType)) {
            return deprecatedMappings[nodeType];
        }

        // Strategy 2: Try node-red-contrib-{nodeType} pattern (most common)
        var contribModule = 'node-red-contrib-' + nodeType;
        
        // Strategy 3: Try node-red-node-{nodeType} pattern (older contrib nodes)
        var nodeModule = 'node-red-node-' + nodeType;

        // Strategy 4: Convert camelCase to kebab-case and try patterns
        var kebabType = camelToKebab(nodeType);
        var contribKebab = 'node-red-contrib-' + kebabType;
        var nodeKebab = 'node-red-node-' + kebabType;

        // Return the most likely candidate (contrib pattern is more common)
        // The actual check if module exists will be done during installation
        return contribModule;
    }

    /**
     * Check which modules are already installed
     * Returns object with module names as keys and boolean values
     */
    function checkModulesInstalled(moduleNames) {
        if (!moduleNames || !Array.isArray(moduleNames)) {
            return {};
        }

        var installed = {};
        var moduleList = {};

        // Get installed modules from registry
        if (RED.nodes && RED.nodes.registry && RED.nodes.registry.getModuleList) {
            moduleList = RED.nodes.registry.getModuleList();
        }

        moduleNames.forEach(function(moduleName) {
            installed[moduleName] = moduleList.hasOwnProperty(moduleName);
        });

        return installed;
    }

    /**
     * Install a module via REST API
     * Returns a Promise that resolves on success or rejects on error
     */
    function installModule(moduleName, version) {
        version = version || 'latest';

        return new Promise(function(resolve, reject) {
            var requestBody = {
                module: moduleName,
                version: version
            };

            $.ajax({
                url: 'nodes',
                type: 'POST',
                data: JSON.stringify(requestBody),
                contentType: 'application/json; charset=utf-8'
            }).done(function(data, textStatus, xhr) {
                resolve(data);
            }).fail(function(xhr, textStatus, err) {
                var error = new Error('Failed to install module: ' + moduleName);
                error.code = xhr.status === 404 ? 'not_found' : 'install_failed';
                error.status = xhr.status;
                error.response = xhr.responseJSON || xhr.responseText;
                reject(error);
            });
        });
    }

    /**
     * Handle installation error and return user-friendly message
     */
    function handleInstallError(error, moduleName) {
        var message = 'Failed to install module: ' + moduleName + '. ';

        if (error.code === 'not_found' || error.status === 404) {
            message += 'Module not found. Please install manually: npm install ' + moduleName;
        } else if (error.code === 'install_failed') {
            message += 'Installation failed. Check the Node-RED logs for details.';
        } else if (error.status === 403 || error.status === 401) {
            message += 'Permission denied. Check your Node-RED installation permissions.';
        } else {
            message += 'Error: ' + (error.message || 'Unknown error');
        }

        return message;
    }

    /**
     * Show installation progress message
     */
    function showInstallProgress(moduleName) {
        return 'Installing ' + moduleName + '...';
    }

    /**
     * Show installation prompt dialog
     * Returns a Promise that resolves with user's choice (true = install, false = cancel)
     */
    function showInstallPrompt(missingModules, callback) {
        if (!missingModules || missingModules.length === 0) {
            if (callback) {
                callback(false);
            }
            return Promise.resolve(false);
        }

        return new Promise(function(resolve) {
            var moduleList = missingModules.map(function(m) {
                return m.moduleName || m;
            }).join(', ');

            var message = 'The flow requires the following modules that are not installed:\n\n' +
                         moduleList + '\n\n' +
                         'Would you like to install them now?';

            var userChoice = confirm(message);
            
            if (callback) {
                callback(userChoice);
            }
            resolve(userChoice);
        });
    }

    /**
     * Map node types to module names
     * Returns array of objects: [{nodeType: "...", moduleName: "..."}, ...]
     */
    function mapNodeTypesToModules(nodeTypes) {
        if (!nodeTypes || !Array.isArray(nodeTypes)) {
            return [];
        }

        var mapped = [];
        var seenModules = {};

        nodeTypes.forEach(function(nodeType) {
            var moduleName = getModuleNameForNodeType(nodeType);
            if (moduleName && !seenModules[moduleName]) {
                seenModules[moduleName] = true;
                mapped.push({
                    nodeType: nodeType,
                    moduleName: moduleName
                });
            }
        });

        return mapped;
    }

    return {
        getModuleNameForNodeType: getModuleNameForNodeType,
        checkModulesInstalled: checkModulesInstalled,
        installModule: installModule,
        handleInstallError: handleInstallError,
        showInstallProgress: showInstallProgress,
        showInstallPrompt: showInstallPrompt,
        mapNodeTypesToModules: mapNodeTypesToModules
    };
})();

