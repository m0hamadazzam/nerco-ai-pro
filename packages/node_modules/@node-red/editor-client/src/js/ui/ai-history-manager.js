/**
 * AI History Manager
 * Manages separate chat history for each model/provider combination
 */
RED.aiHistoryManager = (function() {
    // Constants
    const MAX_STORED_MESSAGES = 100;
    const MAX_STORED_MESSAGES_FALLBACK = 50;
    const MAX_LOCALSTORAGE_SIZE = 4 * 1024 * 1024; // 4MB (conservative limit)
    const MAX_HISTORY_AGE_DAYS = 30; // Clean up histories older than 30 days
    
    var histories = {}; // { "provider:model:apiKeyId": [...] }
    var currentKey = null;

    /**
     * Generate history key from provider, model, and apiKeyId
     */
    function getHistoryKey(provider, model, apiKeyId) {
        if (!provider || !model || !apiKeyId) {
            return null;
        }
        return provider + ':' + model + ':' + apiKeyId;
    }

    /**
     * Get history for a specific model
     */
    function getHistory(provider, model, apiKeyId) {
        var key = getHistoryKey(provider, model, apiKeyId);
        if (!key) {
            return [];
        }
        
        if (!histories[key]) {
            histories[key] = [];
            // Load from localStorage if exists
            loadFromStorage(key);
        }
        
        return histories[key];
    }

    /**
     * Switch to a different model's history
     */
    function switchHistory(provider, model, apiKeyId) {
        var newKey = getHistoryKey(provider, model, apiKeyId);
        if (!newKey) {
            return [];
        }
        
        // Save current history before switching
        if (currentKey && currentKey !== newKey) {
            saveToStorage(currentKey);
        }
        
        // Switch to new history
        currentKey = newKey;
        
        // Load new history if not already loaded
        if (!histories[currentKey]) {
            histories[currentKey] = [];
            loadFromStorage(currentKey);
        }
        
        return histories[currentKey];
    }

    /**
     * Add a message to the current history
     */
    function addMessage(role, content, metadata) {
        if (!currentKey) {
            return;
        }
        
        var message = {
            role: role,
            content: content
        };
        
        // Add metadata if provided (e.g., isFlow, isUpdate)
        if (metadata) {
            Object.assign(message, metadata);
        }
        
        histories[currentKey].push(message);
        saveToStorage(currentKey);
    }

    /**
     * Clear history for a specific model
     */
    function clearHistory(provider, model, apiKeyId) {
        var key = getHistoryKey(provider, model, apiKeyId);
        if (key) {
            histories[key] = [];
            localStorage.removeItem('ai_history_' + key);
            
            // If clearing current history, reset currentKey
            if (currentKey === key) {
                currentKey = null;
            }
        }
    }

    /**
     * Get current history
     */
    function getCurrentHistory() {
        if (!currentKey || !histories[currentKey]) {
            return [];
        }
        return histories[currentKey];
    }

    /**
     * Get current history key
     */
    function getCurrentKey() {
        return currentKey;
    }

    /**
     * Load history from localStorage
     */
    function loadFromStorage(key) {
        try {
            var stored = localStorage.getItem('ai_history_' + key);
            if (stored) {
                var parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    // Filter out old messages (older than MAX_HISTORY_AGE_DAYS)
                    var now = Date.now();
                    var maxAge = MAX_HISTORY_AGE_DAYS * 24 * 60 * 60 * 1000;
                    histories[key] = parsed.filter(function(msg) {
                        if (!msg.timestamp) {
                            return true; // Keep messages without timestamp (assume recent)
                        }
                        return (now - msg.timestamp) < maxAge;
                    });
                    
                    // If we filtered out messages, save the cleaned version
                    if (histories[key].length < parsed.length) {
                        saveToStorage(key);
                    }
                }
            }
        } catch (e) {
            if (RED.log && RED.log.warn) {
                RED.log.warn('Failed to load history from storage:', e);
            } else {
                console.warn('Failed to load history from storage:', e);
            }
            histories[key] = [];
        }
    }

    /**
     * Save history to localStorage with size checking
     */
    function saveToStorage(key) {
        if (!histories[key]) {
            return;
        }
        
        try {
            // Limit stored history to avoid localStorage size limits
            var toStore = histories[key].slice(-MAX_STORED_MESSAGES);
            var dataString = JSON.stringify(toStore);
            
            // Check size before storing
            if (dataString.length > MAX_LOCALSTORAGE_SIZE) {
                // Try with fewer messages
                toStore = histories[key].slice(-MAX_STORED_MESSAGES_FALLBACK);
                dataString = JSON.stringify(toStore);
            }
            
            localStorage.setItem('ai_history_' + key, dataString);
        } catch (e) {
            // If storage is full, try storing even less
            if (e.name === 'QuotaExceededError' || e.code === 22) {
                try {
                    var toStore = histories[key].slice(-MAX_STORED_MESSAGES_FALLBACK);
                    var dataString = JSON.stringify(toStore);
                    if (dataString.length > MAX_LOCALSTORAGE_SIZE) {
                        // Last resort: store only last 25 messages
                        toStore = histories[key].slice(-25);
                        dataString = JSON.stringify(toStore);
                    }
                    localStorage.setItem('ai_history_' + key, dataString);
                } catch (e2) {
                    // Use RED.log if available, otherwise console.warn
                    if (RED.log && RED.log.warn) {
                        RED.log.warn('Failed to save history to storage (quota exceeded):', e2);
                    } else {
                        console.warn('Failed to save history to storage (quota exceeded):', e2);
                    }
                }
            } else {
                // Other errors
                if (RED.log && RED.log.warn) {
                    RED.log.warn('Failed to save history to storage:', e);
                } else {
                    console.warn('Failed to save history to storage:', e);
                }
            }
        }
    }

    /**
     * Get all history keys (for debugging/admin)
     */
    function getAllHistoryKeys() {
        return Object.keys(histories);
    }

    /**
     * Clear all histories
     */
    function clearAllHistories() {
        histories = {};
        currentKey = null;
        
        // Clear all from localStorage
        var keys = Object.keys(localStorage);
        keys.forEach(function(key) {
            if (key.startsWith('ai_history_')) {
                localStorage.removeItem(key);
            }
        });
    }
    
    /**
     * Clean up old histories (older than MAX_HISTORY_AGE_DAYS)
     */
    function cleanupOldHistories() {
        var now = Date.now();
        var maxAge = MAX_HISTORY_AGE_DAYS * 24 * 60 * 60 * 1000;
        var cleaned = false;
        
        // Clean in-memory histories
        for (var key in histories) {
            if (histories.hasOwnProperty(key)) {
                var originalLength = histories[key].length;
                histories[key] = histories[key].filter(function(msg) {
                    if (!msg.timestamp) {
                        return true; // Keep messages without timestamp
                    }
                    return (now - msg.timestamp) < maxAge;
                });
                
                if (histories[key].length < originalLength) {
                    cleaned = true;
                    saveToStorage(key);
                }
            }
        }
        
        // Clean localStorage (remove keys that are no longer in memory)
        var keys = Object.keys(localStorage);
        keys.forEach(function(key) {
            if (key.startsWith('ai_history_')) {
                var historyKey = key.replace('ai_history_', '');
                if (!histories[historyKey] || histories[historyKey].length === 0) {
                    localStorage.removeItem(key);
                    cleaned = true;
                }
            }
        });
        
        return cleaned;
    }
    
    /**
     * Initialize and run cleanup on startup
     */
    function init() {
        cleanupOldHistories();
    }

    return {
        init: init,
        getHistory: getHistory,
        switchHistory: switchHistory,
        addMessage: addMessage,
        clearHistory: clearHistory,
        getCurrentHistory: getCurrentHistory,
        getCurrentKey: getCurrentKey,
        getAllHistoryKeys: getAllHistoryKeys,
        clearAllHistories: clearAllHistories,
        cleanupOldHistories: cleanupOldHistories
    };
})();

