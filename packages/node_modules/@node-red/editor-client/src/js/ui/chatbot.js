RED.chatbot = (function () {
    var content = null;
    var chatContainer = null;
    var messageContainer = null;
    var inputContainer = null;
    var chatHistory = [];
    var isProcessing = false;
    var apiKeyContainer = null;
    var modelSelector = null;
    var selectedProvider = null;
    var selectedModel = null;
    var selectedApiKeyId = null;

    // Storage keys
    const STORAGE_KEY_AI_ASSISTANT = 'aiAssistant';

    function checkApiKey() {
        // Check if any provider has at least one enabled API key
        var aiProviders = RED.settings.get('aiProviders', {});
        for (var providerId in aiProviders) {
            var provider = aiProviders[providerId];
            if (provider && provider.keys && provider.keys.length > 0) {
                var hasEnabledKey = provider.keys.some(function (key) {
                    return key.enabled && key.apiKey && key.apiKey.trim().length > 0;
                });
                if (hasEnabledKey) {
                    return true;
                }
            }
        }
        // Legacy check
        var legacyKey = localStorage.getItem('node-red-openai-api-key');
        return legacyKey && legacyKey.trim().length > 0;
    }

    function getAvailableModels() {
        var aiProviders = RED.settings.get('aiProviders', {});
        var availableModels = [];
        var providers = RED.aiModels.getAllProviders();

        providers.forEach(function (providerInfo) {
            var providerId = providerInfo.id;
            var provider = aiProviders[providerId];
            var hasKeys = provider && provider.keys && provider.keys.some(function (k) {
                return k.enabled && k.apiKey && k.apiKey.trim().length > 0;
            });

            if (hasKeys) {
                var models = RED.aiModels.getAvailableModels(providerId);
                models.forEach(function (model) {
                    // For each model, show it with each available key
                    var keys = provider.keys.filter(function (k) {
                        return k.enabled && k.apiKey && k.apiKey.trim().length > 0;
                    });
                    keys.forEach(function (key) {
                        availableModels.push({
                            providerId: providerId,
                            providerName: providerInfo.name,
                            providerIcon: providerInfo.icon,
                            providerColor: providerInfo.color,
                            modelId: model.id,
                            modelName: model.name,
                            apiKeyId: key.id,
                            apiKeyName: key.name || 'Default'
                        });
                    });
                });
            }
        });

        return availableModels;
    }

    function loadSelectedModel() {
        var aiAssistant = RED.settings.get(STORAGE_KEY_AI_ASSISTANT, {});
        selectedProvider = aiAssistant.selectedProvider || 'openai';
        selectedModel = aiAssistant.selectedModel || 'gpt-4o';
        selectedApiKeyId = aiAssistant.selectedApiKeyId;

        // Validate selection still exists
        var availableModels = getAvailableModels();
        var found = availableModels.find(function (m) {
            return m.providerId === selectedProvider &&
                m.modelId === selectedModel &&
                m.apiKeyId === selectedApiKeyId;
        });

        if (!found && availableModels.length > 0) {
            // Use first available model
            var first = availableModels[0];
            selectedProvider = first.providerId;
            selectedModel = first.modelId;
            selectedApiKeyId = first.apiKeyId;
            saveSelectedModel();
        }
    }

    function saveSelectedModel() {
        var aiAssistant = {
            selectedProvider: selectedProvider,
            selectedModel: selectedModel,
            selectedApiKeyId: selectedApiKeyId
        };
        RED.settings.set(STORAGE_KEY_AI_ASSISTANT, aiAssistant);
    }

    function saveApiKey(apiKey) {
        // Save API key to localStorage
        localStorage.setItem('node-red-openai-api-key', apiKey);
        // Update the key in the OpenAI service
        RED.openAIService.updateApiKey(apiKey);
    }

    function createApiKeyInput() {
        apiKeyContainer = $('<div class="red-ui-chatbot-api-key-container"></div>');

        // Create a centered card container
        var card = $('<div class="red-ui-chatbot-api-key-card"></div>').appendTo(apiKeyContainer);

        var title = $('<h3>API Key Required</h3>').appendTo(card);

        var description = $('<p>Please configure your AI provider API keys in settings to use the Nerco AI Assistant.</p>').appendTo(card);

        var buttonGroup = $('<div class="red-ui-chatbot-api-key-button-group"></div>').appendTo(card);

        var settingsButton = $('<button class="red-ui-button">Open Settings</button>').appendTo(buttonGroup);

        settingsButton.on('click', function () {
            RED.actions.invoke("core:show-user-settings");
            // Close the API key container after a short delay to allow settings to open
            setTimeout(function () {
                if (checkApiKey()) {
                    apiKeyContainer.remove();
                    chatContainer.show();
                    updateModelSelector();
                }
            }, 500);
        });

        return apiKeyContainer;
    }

    function createModelSelector() {
        var selectorContainer = $('<div class="red-ui-chatbot-model-selector"></div>');

        var selectorWrapper = $('<div class="red-ui-chatbot-model-selector-wrapper"></div>').appendTo(selectorContainer);

        var label = $('<label>Model:</label>').appendTo(selectorWrapper);

        modelSelector = $('<select class="red-ui-chatbot-model-select"></select>').appendTo(selectorWrapper);

        updateModelSelector();

        modelSelector.on('change', function () {
            var selectedValue = modelSelector.val();
            if (selectedValue) {
                var parts = selectedValue.split('|');
                selectedProvider = parts[0];
                selectedModel = parts[1];
                selectedApiKeyId = parts[2];
                saveSelectedModel();

                // Show brief loading indicator
                var loadingMsg = $('<div class="red-ui-chatbot-message red-ui-chatbot-message-system" style="opacity: 0.7; font-size: 12px; padding: 5px 15px;"></div>')
                    .appendTo(messageContainer);
                $('<div class="red-ui-chatbot-message-text">Switched to ' + selectedProvider + ' ' + selectedModel + '</div>')
                    .appendTo(loadingMsg);
                scrollToBottom();
                setTimeout(function () {
                    loadingMsg.fadeOut(function () {
                        loadingMsg.remove();
                    });
                }, 2000);
            }
        });

        return selectorContainer;
    }

    function updateModelSelector() {
        if (!modelSelector) return;

        modelSelector.empty();
        var availableModels = getAvailableModels();

        if (availableModels.length === 0) {
            modelSelector.append($('<option>No API keys configured</option>'));
            modelSelector.prop('disabled', true);
            return;
        }

        modelSelector.prop('disabled', false);
        loadSelectedModel();

        availableModels.forEach(function (model) {
            var option = $('<option></option>')
                .val(model.providerId + '|' + model.modelId + '|' + model.apiKeyId)
                .text(model.providerName + ' ' + model.modelName + (model.apiKeyName !== 'Default' ? ' (' + model.apiKeyName + ')' : ''))
                .appendTo(modelSelector);

            // Add provider icon/color styling
            option.data('provider-color', model.providerColor);
        });

        // Set selected value
        if (selectedProvider && selectedModel && selectedApiKeyId) {
            var selectedValue = selectedProvider + '|' + selectedModel + '|' + selectedApiKeyId;
            modelSelector.val(selectedValue);
        } else if (availableModels.length > 0) {
            // Select first available
            var first = availableModels[0];
            selectedProvider = first.providerId;
            selectedModel = first.modelId;
            selectedApiKeyId = first.apiKeyId;
            saveSelectedModel();
            modelSelector.val(selectedProvider + '|' + selectedModel + '|' + selectedApiKeyId);
        }
    }

    function createChatbotContent() {
        content = $('<div class="red-ui-chatbot"></div>');

        // Create the chat container
        chatContainer = $('<div class="red-ui-chatbot-container"></div>').appendTo(content);

        // Add model selector
        var selector = createModelSelector();
        chatContainer.append(selector);

        messageContainer = $('<div class="red-ui-chatbot-messages"></div>').appendTo(chatContainer);

        // Add welcome message
        addSystemMessage("Hi ðŸ‘‹ I can help you create flows or answer questions about Node-RED. Ask me anything or describe a flow you'd like to build.");

        // Input area
        inputContainer = $('<div class="red-ui-chatbot-input"></div>').appendTo(chatContainer);
        var textarea = $('<textarea class="red-ui-chatbot-textarea" placeholder="Ask a question or describe a flow you want to create..."></textarea>').appendTo(inputContainer);
        var buttonContainer = $('<div class="red-ui-chatbot-buttons"></div>').appendTo(inputContainer);
        var sendButton = $('<button class="red-ui-button red-ui-chatbot-send">Send</button>').appendTo(buttonContainer);

        // Event handlers
        textarea.on('keydown', function (event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        });

        sendButton.on('click', function () {
            sendMessage();
        });

        function sendMessage() {
            if (isProcessing) return;

            var message = textarea.val().trim();
            if (message.length === 0) return;

            addUserMessage(message);
            textarea.val('');

            // Process the message
            processUserMessage(message);
        }

        // If no API key, hide chat and show API key input
        if (!checkApiKey()) {
            chatContainer.hide();
            content.prepend(createApiKeyInput());
        } else {
            loadSelectedModel();
            updateModelSelector();
        }

        // Listen for settings changes to update model selector
        RED.events.on('settings:changed', function () {
            if (chatContainer && chatContainer.is(':visible')) {
                updateModelSelector();
            }
        });

        return content;
    }

    function addUserMessage(message) {
        var userMessage = $('<div class="red-ui-chatbot-message red-ui-chatbot-message-user"></div>')
            .appendTo(messageContainer);
        $('<div class="red-ui-chatbot-message-text"></div>')
            .text(message)
            .appendTo(userMessage);

        chatHistory.push({ role: 'user', content: message });
        scrollToBottom();
    }

    function addSystemMessage(message) {
        var systemMessage = $('<div class="red-ui-chatbot-message red-ui-chatbot-message-system"></div>')
            .appendTo(messageContainer);

        // For debugging - log the raw message and parsed content
        var parsedContent = marked(message);

        $('<div class="red-ui-chatbot-message-text"></div>')
            .html(parsedContent)
            .appendTo(systemMessage);

        if (message !== "Welcome to Node-RED Assistant! I can help you create flows or answer questions about Node-RED. Ask me anything or describe a flow you'd like to build.") {
            chatHistory.push({ role: 'assistant', content: message });
        }
        scrollToBottom();
    }

    function addFlowMessage(flowJson, flowDescription) {
        var flowMessage = $('<div class="red-ui-chatbot-message red-ui-chatbot-message-flow"></div>')
            .appendTo(messageContainer);

        // Parse markdown and log for debugging
        var parsedContent = marked(flowDescription);

        $('<div class="red-ui-chatbot-message-text"></div>')
            .html(parsedContent)
            .appendTo(flowMessage);

        var flowActionContainer = $('<div class="red-ui-chatbot-flow-actions"></div>')
            .appendTo(flowMessage);

        $('<button class="red-ui-button red-ui-button-small">Insert Flow</button>')
            .on('click', function () {
                insertFlow(flowJson);
            })
            .appendTo(flowActionContainer);

        scrollToBottom();
    }

    function scrollToBottom() {
        messageContainer.scrollTop(messageContainer[0].scrollHeight);
    }

    function processUserMessage(message) {
        isProcessing = true;


        // Show typing indicator
        var processingMessage = $('<div class="red-ui-chatbot-message red-ui-chatbot-message-system red-ui-chatbot-message-typing"></div>')
            .appendTo(messageContainer);
        $('<div class="red-ui-chatbot-message-text">Thinking...</div>')
            .appendTo(processingMessage);
        scrollToBottom();

        // Get available node types for context
        var nodeTypes = RED.nodes.registry.getNodeDefinitions();

        const activeTabId = RED.workspaces.active();
        const nodesInWorkspace = RED.nodes.filterNodes({ z: activeTabId });
        exportable_json = RED.nodes.createCompleteNodeSet({});

        filtered_exportable_json = exportable_json.filter(node => {

            if (nodesInWorkspace.find(n => n.id === node.id)) {
                return true;
            }
            return false;
        })

        // Get the response from AI service with selected provider/model
        loadSelectedModel();
        RED.openAIService.processMessage(message, chatHistory, nodeTypes, filtered_exportable_json, selectedProvider, selectedModel, selectedApiKeyId)
            .then(function (result) {
                console.log(result, "result");
                processingMessage.remove();

                if (result.success) {
                    if (result.isFlow) {
                        // Add the flow message with insert action
                        addFlowMessage(result.flow, result.description);

                        // Add to chat history
                        chatHistory.push({
                            role: 'assistant',
                            content: result.description
                        });
                    }
                    else if (result.isUpdate) {
                        // Add update flow response
                        updateFlowMessage(result.flow, result.description, result.changes, activeTabId);
                    }
                    else {
                        // Add normal conversation response
                        addSystemMessage(result.content);
                    }
                } else {
                    // Add error message
                    addSystemMessage("I'm sorry, an error occurred: " + (result.error || "Unknown error"));
                }

                isProcessing = false;
            })
            .catch(function (error) {
                processingMessage.remove();
                console.error("Error processing message:", error);

                // Parse error messages to show user-friendly text
                let errorMessage = "I'm sorry, an error occurred while processing your message.";

                if (error && error.message) {
                    const errorMsg = error.message.toString();

                    // Distinguish between different error types
                    var providerName = selectedProvider || 'AI';
                    if (errorMsg.includes('API key') || errorMsg.includes('not configured') || errorMsg.includes('not found')) {
                        errorMessage = "API key error: Please check your " + providerName + " API key in the settings. The key may be invalid, expired, or not configured.";
                    } else if (errorMsg.includes('Rate limit') || errorMsg.includes('429')) {
                        errorMessage = "Rate limit exceeded: Too many requests. Please wait a moment and try again.";
                    } else if (errorMsg.includes('Network error') || errorMsg.includes('fetch')) {
                        errorMessage = "Network error: Unable to connect to " + providerName + ". Please check your internet connection and try again.";
                    } else if (errorMsg.includes('Server error') || errorMsg.includes('5')) {
                        errorMessage = "Server error: " + providerName + " servers are experiencing issues. Please try again in a few moments.";
                    } else if (errorMsg.includes('Invalid request') || errorMsg.includes('400')) {
                        errorMessage = "Invalid request: " + (errorMsg.includes(':') ? errorMsg.split(':')[1].trim() : "Please check your input and try again.");
                    } else if (errorMsg.includes('API Error')) {
                        // Extract the actual error message from API Error prefix
                        errorMessage = errorMsg.replace(/^\w+ API Error: /, '');
                    } else {
                        errorMessage = errorMessage + " " + errorMsg;
                    }
                } else if (error && typeof error === 'string') {
                    errorMessage = errorMessage + " " + error;
                }

                addSystemMessage(errorMessage);
                isProcessing = false;
            });
    }

    function insertFlow(flowJson) {
        // Convert the flow to the format expected by Node-RED
        // Use RED.view to import the nodes at the current mouse position
        console.log(flowJson, "flowJson");

        // Handle different flow formats
        var nodesArray = null;
        
        if (Array.isArray(flowJson)) {
            // Already an array
            nodesArray = flowJson;
        } else if (typeof flowJson === 'string') {
            // Try to parse as JSON string
            try {
                var parsed = JSON.parse(flowJson);
                if (Array.isArray(parsed)) {
                    nodesArray = parsed;
                } else if (parsed && Array.isArray(parsed.nodes)) {
                    nodesArray = parsed.nodes;
                } else if (parsed && Array.isArray(parsed.flow)) {
                    nodesArray = parsed.flow;
                }
            } catch (e) {
                console.error('Failed to parse flow JSON string:', e);
            }
        } else if (flowJson && typeof flowJson === 'object') {
            // Object with nodes property
            if (Array.isArray(flowJson.nodes)) {
                nodesArray = flowJson.nodes;
            } else if (Array.isArray(flowJson.flow)) {
                nodesArray = flowJson.flow;
            } else if (Array.isArray(flowJson)) {
                nodesArray = flowJson;
            }
        }

        // Validate and sanitize flow JSON before importing
        if (!nodesArray || !Array.isArray(nodesArray)) {
            console.error('Invalid flow format:', flowJson);
            addSystemMessage("Error: Invalid flow format. Expected an array of nodes or an object with a 'nodes' property.");
            return;
        }

        // Filter out invalid nodes and ensure all nodes have required properties
        var validFlowJson = nodesArray.filter(function (node) {
            // Must have a type property
            if (!node || typeof node !== 'object' || !node.type || typeof node.type !== 'string') {
                console.warn('Skipping invalid node:', node);
                return false;
            }
            // Ensure required properties exist
            if (node.type !== 'tab' && node.type !== 'subflow' && node.type !== 'group') {
                if (typeof node.x !== 'number' || typeof node.y !== 'number') {
                    console.warn('Skipping node without valid x/y coordinates:', node);
                    return false;
                }
            }
            return true;
        });

        if (validFlowJson.length === 0) {
            addSystemMessage("Error: No valid nodes found in the flow.");
            return;
        }

        if (validFlowJson.length < nodesArray.length) {
            addSystemMessage("Warning: Some nodes were invalid and were skipped.");
        }

        change_ids(validFlowJson);
        RED.view.importNodes(validFlowJson, {
            addFlow: false,
            touchImport: false,
            generateIds: false,
            generateDefaultNames: false
        });

        // Add confirmation message
        addSystemMessage("Flow has been added to the workspace!");
    }

    function change_ids(flowJson) {
        current_ids_to_new_ids = {};
        // First pass: generate new IDs for all nodes that have an ID
        for (var i = 0; i < flowJson.length; i++) {
            if (flowJson[i] && flowJson[i].id) {
                current_ids_to_new_ids[flowJson[i].id] = RED.nodes.id();
            }
        }
        // Second pass: update node IDs and wire references
        for (var i = 0; i < flowJson.length; i++) {
            if (!flowJson[i]) continue;
            
            // Update node ID if it exists
            if (flowJson[i].id && current_ids_to_new_ids[flowJson[i].id]) {
                flowJson[i].id = current_ids_to_new_ids[flowJson[i].id];
            } else if (!flowJson[i].id) {
                // Generate new ID if node doesn't have one
                flowJson[i].id = RED.nodes.id();
            }
            
            // Update wire references
            if (flowJson[i].wires !== undefined && Array.isArray(flowJson[i].wires)) {
                if (flowJson[i].wires.length > 0 && Array.isArray(flowJson[i].wires[0])) {
                    // Handle nested array case
                    for (var j = 0; j < flowJson[i].wires.length; j++) {
                        if (Array.isArray(flowJson[i].wires[j])) {
                            for (var k = 0; k < flowJson[i].wires[j].length; k++) {
                                if (flowJson[i].wires[j][k] && current_ids_to_new_ids[flowJson[i].wires[j][k]]) {
                                    flowJson[i].wires[j][k] = current_ids_to_new_ids[flowJson[i].wires[j][k]];
                                }
                            }
                        }
                    }
                } else {
                    // Handle flat array case
                    for (var j = 0; j < flowJson[i].wires.length; j++) {
                        if (flowJson[i].wires[j] && current_ids_to_new_ids[flowJson[i].wires[j]]) {
                            flowJson[i].wires[j] = current_ids_to_new_ids[flowJson[i].wires[j]];
                        }
                    }
                }
            }
        }
    }

    function updateFlowMessage(flow, description, changes, activeTabId) {
        var flowMessage = $('<div class="red-ui-chatbot-message red-ui-chatbot-message-flow"></div>')
            .appendTo(messageContainer);
        var parsedContent = marked(description);
        // Add general explanation
        $('<div class="red-ui-chatbot-message-text"></div>')
            .html(parsedContent)
            .appendTo(flowMessage);

        // Add changes list
        var changesList = $('<div class="red-ui-chatbot-changes-list"></div>')
            .appendTo(flowMessage);

        // Process each change
        changes.forEach(function (change) {
            var changeItem = $('<div class="red-ui-chatbot-change-item"></div>')
                .appendTo(changesList);

            // Add colored dot based on change type
            var dotColor;
            switch (change.operation) {
                case 'add':
                    dotColor = '#2ecc71'; // green
                    break;
                case 'remove':
                    dotColor = '#e74c3c'; // red
                    break;
                case 'modify':
                    dotColor = '#f1c40f'; // orange
                    break;
            }

            $('<span class="red-ui-chatbot-change-dot"></span>')
                .css({
                    'background-color': dotColor,
                    'display': 'inline-block',
                    'width': '8px',
                    'height': '8px',
                    'border-radius': '50%',
                    'margin-right': '8px'
                })
                .appendTo(changeItem);

            // Add change explanation
            $('<span></span>')
                .text(change.description)
                .appendTo(changeItem);
        });

        var flowActionContainer = $('<div class="red-ui-chatbot-flow-actions"></div>')
            .appendTo(flowMessage);

        // Add update button
        $('<button class="red-ui-button red-ui-button-small">Update Flow</button>')
            .on('click', function () {
                updateFlow(flow, changes, activeTabId);
            })
            .appendTo(flowActionContainer);

        scrollToBottom();
    }

    function updateFlow(flow, changes, activeTabId) {
        // Get all nodes in current workspace
        const nodesInWorkspace = RED.nodes.filterNodes({ z: activeTabId });

        // Create a promise chain for sequential execution with delays
        Promise.resolve()
            .then(() => {
                RED.actions.invoke("core:select-all-nodes");
                return new Promise(resolve => setTimeout(resolve, 100));
            })
            .then(() => {
                RED.actions.invoke("core:delete-selection");
                return new Promise(resolve => setTimeout(resolve, 100));
            })
            .then(() => {
                // Import the new nodes
                flow.forEach(node => {
                    if (node.wires.length > 0 && Array.isArray(node.wires[0])) {
                        // Before flattening, store the original number of outputs
                        node.wires = [].concat(...node.wires);
                        node.outputs = node.wires.length;
                    } else {
                        // For non-nested wires, set outputs to 1 if there are any wires
                        node.outputs = node.wires.length
                    }
                    node.x = Number(node.x) + 100;
                    node.y = Number(node.y) + 100;
                });

                // Import with new IDs
                RED.view.importNodes(flow, {
                    addFlow: false,
                    touchImport: false,
                    generateIds: false,
                });
                return new Promise(resolve => setTimeout(resolve, 100));
            })
            .then(() => {
                // RED.actions.invoke("core:select-all-nodes");
                return new Promise(resolve => setTimeout(resolve, 100));
            })
            .then(() => {
                RED.actions.invoke("core:distribute-selection-horizontally");
                return new Promise(resolve => setTimeout(resolve, 100));
            })
            .then(() => {
                addSystemMessage("Flow has been updated!");
            });
    }

    function init() {
        // Initialize the OpenAI service
        RED.openAIService.init();

        // Create tab content
        var sidebarContent = createChatbotContent();

        // Add the tab to the sidebar
        RED.sidebar.addTab({
            id: "chatbot",
            label: "Assistant",
            name: "AI Assistant",
            content: sidebarContent,
            iconClass: "fa fa-comments",
            enableOnEdit: true
        });

        // Update the tab order to place the chatbot tab first
        var currentOrder = RED.settings.get("editor.sidebar.order", ["info", "help", "version-control", "debug"]);
        var newOrder = ["chatbot"].concat(currentOrder.filter(id => id !== "chatbot"));
        RED.settings.set("editor.sidebar.order", newOrder);

        // Show the chatbot tab
        RED.sidebar.show("chatbot");
    }

    return {
        init: init
    };
})(); 
