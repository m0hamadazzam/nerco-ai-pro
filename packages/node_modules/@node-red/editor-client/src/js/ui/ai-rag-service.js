/**
 * AI RAG Service
 * Retrieval Augmented Generation for node types and patterns
 * Uses keyword-based retrieval (can be enhanced with embeddings later)
 */
RED.aiRAGService = (function() {
    var knowledgeBase = [];
    var initialized = false;

    /**
     * Extract keywords from text
     */
    function extractKeywords(text) {
        if (!text || typeof text !== 'string') {
            return [];
        }
        
        // Simple keyword extraction (can be enhanced)
        var words = text.toLowerCase()
            .replace(/[^\w\s]/g, ' ')
            .split(/\s+/)
            .filter(function(word) {
                // Filter out common stop words
                var stopWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'should', 'could', 'may', 'might', 'must', 'can', 'this', 'that', 'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they', 'what', 'which', 'who', 'where', 'when', 'why', 'how'];
                return word.length > 2 && stopWords.indexOf(word) === -1;
            });
        
        // Return unique keywords
        return [...new Set(words)];
    }

    /**
     * Calculate simple text similarity (keyword overlap)
     */
    function calculateSimilarity(queryKeywords, docKeywords) {
        if (!queryKeywords || queryKeywords.length === 0) return 0;
        if (!docKeywords || docKeywords.length === 0) return 0;
        
        var matches = 0;
        queryKeywords.forEach(function(keyword) {
            if (docKeywords.indexOf(keyword) !== -1) {
                matches++;
            }
        });
        
        return matches / queryKeywords.length;
    }

    /**
     * Build knowledge base from node types
     */
    function buildKnowledgeBase(nodeTypes) {
        if (!nodeTypes) {
            return;
        }
        
        knowledgeBase = [];
        
        // Process each node type
        for (var nodeType in nodeTypes) {
            if (nodeTypes.hasOwnProperty(nodeType)) {
                var def = nodeTypes[nodeType];
                
                // Skip if no type property (shouldn't happen, but safety check)
                if (!def.type && !nodeType) {
                    continue;
                }
                
                // Use def.type if available, otherwise use the key
                var actualType = def.type || nodeType;
                
                // Extract relevant information
                var content = '';
                var metadata = {
                    nodeType: actualType,
                    category: def.category || 'unknown',
                    tags: []
                };
                
                // Build content from available information
                if (def.name) {
                    content += def.name + '. ';
                    metadata.tags.push(def.name.toLowerCase());
                }
                
                // Add node type itself as a keyword
                metadata.tags.push(actualType.toLowerCase());
                content += 'Node type: ' + actualType + '. ';
                
                if (def.help) {
                    content += def.help + ' ';
                }
                
                if (def.label) {
                    var labelText = typeof def.label === 'function' ? def.label() : def.label;
                    if (labelText) {
                        content += 'Label: ' + labelText + '. ';
                    }
                }
                
                // Add category as keyword
                if (def.category) {
                    metadata.tags.push(def.category.toLowerCase());
                    content += 'Category: ' + def.category + '. ';
                }
                
                // Extract keywords from content
                var keywords = extractKeywords(content);
                metadata.tags = metadata.tags.concat(keywords);
                
                // Add to knowledge base
                knowledgeBase.push({
                    id: 'node-type-' + actualType,
                    type: 'node_type',
                    content: content.trim(),
                    metadata: metadata,
                    keywords: keywords,
                    nodeType: actualType,
                    definition: def
                });
            }
        }
        
        initialized = true;
    }

    /**
     * Search knowledge base for relevant items
     */
    function search(query, options) {
        options = options || {};
        var topK = options.topK || 10;
        var filterType = options.filterType; // 'node_type', 'example', 'pattern'
        var operationType = options.operationType; // 'question', 'create_flow', 'update_flow'
        
        if (!initialized || knowledgeBase.length === 0) {
            return [];
        }
        
        var queryKeywords = extractKeywords(query);
        if (queryKeywords.length === 0) {
            // If no keywords, return all (or top K)
            return knowledgeBase.slice(0, topK);
        }
        
        // Calculate similarity for each item
        var results = knowledgeBase.map(function(item) {
            // Filter by type if specified
            if (filterType && item.type !== filterType) {
                return null;
            }
            
            // Calculate similarity
            var similarity = calculateSimilarity(queryKeywords, item.keywords);
            
            // Boost score for category matches
            if (item.metadata && item.metadata.category) {
                var categoryMatch = queryKeywords.some(function(kw) {
                    return item.metadata.category.toLowerCase().indexOf(kw) !== -1;
                });
                if (categoryMatch) {
                    similarity += 0.2;
                }
            }
            
            return {
                item: item,
                similarity: similarity
            };
        }).filter(function(result) {
            return result !== null && result.similarity > 0;
        });
        
        // Sort by similarity (highest first)
        results.sort(function(a, b) {
            return b.similarity - a.similarity;
        });
        
        // Return top K
        return results.slice(0, topK).map(function(result) {
            return result.item;
        });
    }

    /**
     * Retrieve relevant node types for a query
     */
    function retrieveRelevantNodeTypes(query, operationType, maxResults) {
        maxResults = maxResults || 15;
        
        // Search for relevant node types
        var results = search(query, {
            topK: maxResults,
            filterType: 'node_type',
            operationType: operationType
        });
        
        // Build filtered node types object
        var relevantNodeTypes = {};
        results.forEach(function(result) {
            if (result.nodeType && result.definition) {
                relevantNodeTypes[result.nodeType] = result.definition;
            }
        });
        
        return relevantNodeTypes;
    }

    /**
     * Initialize the RAG service
     */
    function init(nodeTypes) {
        if (nodeTypes) {
            buildKnowledgeBase(nodeTypes);
        }
    }

    /**
     * Rebuild knowledge base (call when node types change)
     */
    function rebuild(nodeTypes) {
        buildKnowledgeBase(nodeTypes);
    }

    return {
        init: init,
        rebuild: rebuild,
        search: search,
        retrieveRelevantNodeTypes: retrieveRelevantNodeTypes,
        isInitialized: function() { return initialized; }
    };
})();

